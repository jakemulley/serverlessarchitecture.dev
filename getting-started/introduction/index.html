


<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Introduction to serverless | Serverless Architecture</title>
  <link rel="stylesheet" href="/css/style.css?v=1642865137386">
</head>

<body class="antialiased bg-white dark:bg-slate-900 text-slate-700 dark:text-slate-200">
  <div class="flex flex-col min-h-screen max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 divide-y-2">
    <header class="py-4 sm:py-6 lg:py-8">
      <a href="/" class="text-xl font-semibold hover:underline">Serverless Architecture</a>
    </header>
    <main class="flex-grow py-8 divide-y">
      <header class="prose prose-slate dark:prose-invert pb-8">
        

        
          <!-- Breadcrumbs -->
          <nav class="not-prose mb-6 text-sm hidden md:block">
            <ol class="flex space-x-3">
              
              <li class="after:content-[&#39;/&#39;] after:ml-3"><a href="" class="hover:underline">Serverless Architecture</a></li>

              
                

                <li class="after:content-[&#39;/&#39;] after:ml-3"><a href="/getting-started/" class="hover:underline">Getting started with serverless</a></li>
              
                
                  
                

                <li class="text-slate-500"><a href="/getting-started/introduction/" class="hover:underline">Introduction to serverless</a></li>
              
            </ol>
          </nav>
          <!-- Breadcrumbs -->
        

        <h1>Introduction to serverless</h1>
        <p class="lead">Learn what serverless is, the advantages and disadvantages of serverless, and when to use it.</p>

        
          <aside class="text-sm">
            <strong>In this article:</strong>

            <nav class="prose-ol:pl-0 prose-li:list-none prose-li:pl-0" >
        <ol><li><a href="#what-is-serverless">What is serverless?</a></li><li><a href="#advantages-of-serverless">Advantages of serverless</a></li><li><a href="#disadvantages-of-serverless">Disadvantages of serverless</a></li></ol>
      </nav>
          </aside>
        
      </header>

      <!-- Content -->
      <div class="pt-8">
        
  <article class="prose prose-slate dark:prose-invert">
    <h2 id="what-is-serverless" tabindex="-1">What is serverless?</h2>
<p>Serverless (short for &quot;serverless computing&quot;) is a cloud-native architectural pattern. It allows developers to focus on developing and running applications and services in the cloud, without having to manage the underlying servers. Serverless is still backed by servers, but the management is abstracted away to a cloud provider, such as <a href="https://aws.amazon.com/">Amazon Web Services (AWS)</a>, <a href="https://azure.microsoft.com">Microsoft Azure (Azure)</a>, or <a href="https://cloud.google.com">Google Cloud Platform (GCP)</a>.</p>
<p>Utilising serverless architecture offsets the need for a developer to provision, maintain, and scale servers. This includes the maintenance, patching, capacity planning and management, scalability, and availability of servers.</p>
<p>Historically, &quot;serverless&quot; has been synonymous with &quot;<a href="https://en.wikipedia.org/wiki/Function_as_a_service">Function as a Service</a>&quot; (FaaS). More recently, cloud providers have started to offer serverless equivalents of traditional infrastructure, such as databases, queuing systems, event buses, blob storage, and API gateways.</p>
<p>That's all serverless is: cloud services that don't require a developer to manage the underlying servers and the complexities that come with that.</p>
<h2 id="advantages-of-serverless" tabindex="-1">Advantages of serverless</h2>
<p>Compared to traditional infrastructure and architectural patterns, serverless can offer lots of advantages, ranging from cost efficiency to increased environmental sustainability.</p>
<h3 id="no-server-management" tabindex="-1">No server management</h3>
<p>Although serverless architectures are still backed by servers, the management aspect is offset to a cloud provider. This means you don't need to manage the server your application runs on. This includes the maintenance, patching, capacity planning and management, scalability, and availability of servers. This frees up your time to focus on building an application, rather than configuring and maintaining the underlying servers.</p>
<h3 id="reduced-cost" tabindex="-1">Reduced cost</h3>
<p>With traditional infrastructure, you'd provision servers based on the projection of usage for an application. This typically means that a server would be over-provisioned, to account for peaks in traffic; and you'd be paying for CPU time or disk space, whether it was in use or not.</p>
<p>With serverless, you are only charged for what is used. You don't need to capacity plan or over-provision, as server provisioning and scaling is dynamic, near real-time, and managed by a cloud provider. This allows serverless infrastructure to automatically scale up and down (including to zero) as needed. This can result in a reduced cost for workloads; as you are not paying for idle compute power when your service has no or low traffic compared to the peaks you may have provisioned for in traditional infrastructure. If your application has no traffic or does not need to run, the cost is zero when using serverless. You no longer need to pay for idle CPU time or unused disk space. Typically, resource utilisation is automatically optimised too, meaning you get value for money.</p>
<p>Further, there is also a reduction in time and people cost, as you don't need to worry about server management; or necessarily have the skills for server management. You can focus on the application you are building.</p>
<h3 id="scalability" tabindex="-1">Scalability</h3>
<p>When utilising serverless, you don't have to worry about scalability. Serverless is inherently scalable by default, and infrastructure will scale up and down based on demand. This includes scaling down to zero when a service is not in use and infinitely up when there is peak demand or an unusual spike in traffic.</p>
<p>You don't need to capacity plan or guess how much compute you need to provision for serverless infrastructure, as it is ready, available, and can be utilised on demand.</p>
<h3 id="increased-productivity" tabindex="-1">Increased productivity</h3>
<p>As serverless gives you time back from managing servers, it can increase your productivity by allowing you to focus on your application rather than server management and configuration.</p>
<p>Serverless is also typically used for microservices, which makes it easier to deploy and manage. You can redeploy, reiterate, or rebuild one microservice at a time rather than redeploying whole monolithic applications.</p>
<h3 id="reduced-latency" tabindex="-1">Reduced latency</h3>
<p>Serverless makes it easier to run your code closer to your users, usually at the edge. You can typically adopt a multi-region architecture without unnecessarily increasing cost, as you don't need to provision servers that run all the time in multiple regions.</p>
<p>This can reduce latency and Time to First Byte for applications if done correctly.</p>
<h3 id="increased-environmental-sustainability" tabindex="-1">Increased environmental sustainability</h3>
<p>Traditional infrastructure is usually on 24 hours a day, 7 days a week. Serverless infrastructure can scale down to zero. This uses less energy than idle CPU time on a provisioned server. Serverless infrastructure is delivered on demand when and as it is needed.</p>
<p>As serverless can scale down to zero and is never over-provisioned, it can increase environmental sustainability for a service. When your service isn't in use, it's not idly running on a server. It scales down to zero, increasing environmental sustainability by using less energy.</p>
<h3 id="reduced-complexity" tabindex="-1">Reduced complexity</h3>
<p>As server management is abstracted away to cloud providers, it can reduce complexity of an application. You no longer need to worry about the operating system, hardware, dependencies, patching or management of the servers. You can focus on your application code.</p>
<p>Serverless also promotes &quot;honest architecture&quot;. People can perceive serverless as more complex; since architectural diagrams for serverless applications tend to be more <em>honest</em> and detailed than traditional infrastructure. Yan Cui of The Burning Monk covers this in more detail in their blog post &quot;<a href="https://theburningmonk.com/2020/11/even-simple-serverless-applications-have-complex-architecture-diagrams-so-what/">Even simple serverless applications have complex architecture diagrams - so what?</a>&quot;.</p>
<h3 id="reduced-time-to-market" tabindex="-1">Reduced time to market</h3>
<p>Since serverless reduces your operational overhead (i.e. server management), it can reduce time to market for an application. It can also enable quicker deployments, and the ability to focus on building an application rather than configuring servers. This allows you to release and iterate quickly, getting your application to market faster.</p>
<h3 id="reduced-security-risk" tabindex="-1">Reduced security risk</h3>
<p>With serverless, you're not managing the server itself. This can reduce your security risk by having one less thing to patch (the server) and allows you to focus on application security instead.</p>
<p>The management of the operating system, hardware, and local dependencies is managed by a cloud provider, who would also typically have more skill and expertise to ensure security in depth.</p>
<h2 id="disadvantages-of-serverless" tabindex="-1">Disadvantages of serverless</h2>
<p>Whilst serverless has many advantages, it also has some disadvantages and different ways of doing things compared to traditional infrastructure. The disadvantages below are common gotchas to be aware of and depend on the context of how serverless infrastructure is used.</p>
<h3 id="learning-curve" tabindex="-1">Learning curve</h3>
<p>Serverless requires a different mindset to traditional infrastructure. With traditional infrastructure, the concepts are largely the same - running software on virtual machines. Serverless has a different way of doing things, and is largely event-driven. This means you need to shift your focus closer to the events that trigger something that is running on serverless infrastructure (e.g. a HTTP request triggering a function).</p>
<p>Best practices in serverless are also different. For example, functions running on Function-as-a-Service infrastructure should do one thing, one thing well, and be small. This is to mitigate other disadvantages, like cold start times.</p>
<h3 id="monitoring-and-debugging" tabindex="-1">Monitoring and debugging</h3>
<p>Serverless makes it harder to monitor requests and responses end-to-end using traditional monitoring tools. Monitoring becomes distributed, and debugging can end up relying on reverse engineering log traces to find the root cause of an issue.</p>
<h3 id="local-testing" tabindex="-1">Local testing</h3>
<p>As serverless removes the need and ability to manage or see anything other than your application code, you have no visibility of the backend processes. This makes it harder (not impossible) to locally test your application as you can't replicate the infrastructure locally.</p>
<p>One way to mitigate this is to always deploy your code, and test it with the serverless service you are using.</p>
<h3 id="different-security-and-compliance-concerns" tabindex="-1">Different security and compliance concerns</h3>
<p>With serverless, as the management of underlying infrastructure is abstracted away to a cloud provider, you are relying on the cloud provider to implement security measures well. Further, you can't perform a penetration test on the underlying server, because you don't have access to it.</p>
<p>Serverless also tends to use servers that are multi-tenancy. This can be an issue for compliance and legal reasons in highly regulated industries.</p>
<h3 id="long-running-processes-have-limitations" tabindex="-1">Long running processes have limitations</h3>
<p>Certain serverless implementations, for example Function-as-a-Service (FaaS), have limitations around long running processes. FaaS tends to have a timeout of less than 30 minutes, which makes it impossible to run long running tasks.</p>
<p>Further, as serverless providers charge for the amount of time code is running, it could end up costing more to run long-running processes using serverless compared to traditional infrastructure.</p>
<h3 id="cold-starts" tabindex="-1">Cold starts</h3>
<p>Cold starts can be an issue in serverless. As serverless infrastructure will scale down to zero when an application is not in use; it may require a cold start when an event invokes the application. This can sometimes be a few seconds.</p>
<p>Although, if a piece of code is used regularly, it will be warm - which means you eliminate the cold start.</p>
<h3 id="vendor-lock-in" tabindex="-1">Vendor lock-in</h3>
<p>Serverless infrastructure tends to be tightly coupled and integrated with cloud provider services and APIs. This can create vendor lock-in, as serverless implementations are non-typical and can vary between cloud providers.</p>
<p>Although, it's important to note that there is always a level of vendor lock-in when utilising a cloud provider, serverless or not.</p>
<h3 id="costs" tabindex="-1">Costs</h3>
<p>Depending on the use case for serverless, it can end up being more expensive than traditional infrastructure. An example of this is if you have a reliable, consistent traffic pattern. It may be cheaper to buy a virtual machine to run your service on.</p>
<p>Although, it does depend on the context and the use case. For example, the time saved by not managing servers may offset the increased costs.</p>


    
  </article>

      </div>
      <!-- Content -->
    </main>
    <footer class="text-sm py-2 sm:py-4">
      <p>&copy; 2022 <a href="https://jakemulley.com/" class="hover:underline">Jake Mulley</a></p>
    </footer>
  </div>
</body>
</html>
